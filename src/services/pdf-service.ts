/**
 * PDF Generation Service
 * Handles PDF creation with QR codes and proper security measures
 */

import jsPDF from "jspdf";
import type {
  PDFGenerationOptions,
  ExportResult,
  QRMetadata,
} from "@/types";

export class PDFService {
  private static instance: PDFService;

  public static getInstance(): PDFService {
    if (!PDFService.instance) {
      PDFService.instance = new PDFService();
    }
    return PDFService.instance;
  }

  /**
   * Generates PDF with QR code and metadata
   */
  public async generatePDF(
    qrDataUrl: string,
    qrText: string,
    options: PDFGenerationOptions = {}
  ): Promise<ExportResult> {
    try {
      if (!qrDataUrl) {
        throw new Error("QR code data URL is required");
      }

      const pdf = this.createPDFDocument(options);
      await this.addContent(pdf, qrDataUrl, qrText, options);
      
      const filename = this.generateFilename(options.title);
      const blob = pdf.output("blob");
      
      this.downloadPDF(pdf, filename);

      return {
        success: true,
        filename,
        size: blob.size,
        format: "pdf",
      };
    } catch (error) {
      return {
        success: false,
        format: "pdf",
        error: error instanceof Error ? error.message : "PDF generation failed",
      };
    }
  }

  /**
   * Creates a new PDF document with configuration
   */
  private createPDFDocument(options: PDFGenerationOptions): jsPDF {
    const pdf = new jsPDF({
      orientation: options.orientation || "portrait",
      unit: "mm",
      format: options.pageSize || "a4",
    });

    // Set document properties
    if (options.title) pdf.setProperties({ title: options.title });
    if (options.author) pdf.setProperties({ author: options.author });
    if (options.subject) pdf.setProperties({ subject: options.subject });
    if (options.keywords) pdf.setProperties({ keywords: options.keywords.join(", ") });

    return pdf;
  }

  /**
   * Adds content to PDF document
   */
  private async addContent(
    pdf: jsPDF,
    qrDataUrl: string,
    qrText: string,
    options: PDFGenerationOptions
  ): Promise<void> {
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margins = options.margins || { top: 20, right: 20, bottom: 20, left: 20 };

    let currentY = margins.top;

    // Add title
    pdf.setFontSize(24);
    pdf.setFont("helvetica", "bold");
    const title = options.title || "QR Code Document";
    pdf.text(title, pageWidth / 2, currentY, { align: "center" });
    currentY += 15;

    // Add subtitle with date
    pdf.setFontSize(12);
    pdf.setFont("helvetica", "normal");
    const currentDate = new Date().toLocaleDateString();
    pdf.text(`Generated on ${currentDate}`, pageWidth / 2, currentY, { align: "center" });
    currentY += 20;

    // Calculate QR code size and position
    const maxQRSize = Math.min(
      pageWidth - margins.left - margins.right,
      pageHeight - currentY - margins.bottom - 60 // Reserve space for text and footer
    );
    const qrSize = Math.min(maxQRSize, 120); // Max 120mm
    const qrX = (pageWidth - qrSize) / 2;

    // Add QR code
    const imageFormat = this.getImageFormat(qrDataUrl);
    pdf.addImage(qrDataUrl, imageFormat, qrX, currentY, qrSize, qrSize);
    currentY += qrSize + 15;

    // Add encoded text
    pdf.setFontSize(10);
    pdf.setFont("helvetica", "bold");
    pdf.text("Encoded Text:", margins.left, currentY);
    currentY += 5;

    // Split and add QR text content
    pdf.setFont("helvetica", "normal");
    const splitText = pdf.splitTextToSize(
      this.sanitizeText(qrText),
      pageWidth - margins.left - margins.right
    );
    pdf.text(splitText, margins.left, currentY);

    // Add footer
    this.addFooter(pdf, pageWidth, pageHeight, margins);
  }

  /**
   * Adds footer to PDF
   */
  private addFooter(
    pdf: jsPDF,
    pageWidth: number,
    pageHeight: number,
    margins: { top: number; right: number; bottom: number; left: number }
  ): void {
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "normal");
    pdf.text(
      "Generated by QR PDF Generator",
      pageWidth / 2,
      pageHeight - margins.bottom,
      { align: "center" }
    );
  }

  /**
   * Downloads the PDF file
   */
  private downloadPDF(pdf: jsPDF, filename: string): void {
    pdf.save(filename);
  }

  /**
   * Generates filename with timestamp
   */
  private generateFilename(title?: string): string {
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, "-");
    const baseName = title ? this.sanitizeFilename(title) : "qr-code";
    return `${baseName}-${timestamp}.pdf`;
  }

  /**
   * Sanitizes filename to remove invalid characters
   */
  private sanitizeFilename(filename: string): string {
    return filename
      .replace(/[^a-zA-Z0-9\-_\s]/g, "")
      .replace(/\s+/g, "-")
      .toLowerCase()
      .slice(0, 50);
  }

  /**
   * Sanitizes text content for PDF
   */
  private sanitizeText(text: string): string {
    // Remove potentially harmful characters and limit length
    const sanitized = text.split('').filter(char => {
      const code = char.charCodeAt(0);
      // Allow newline (10), tab (9), and printable characters (32-126)
      return code === 9 || code === 10 || (code >= 32 && code <= 126) || code > 127;
    }).join('');

    return sanitized.slice(0, 2000); // Limit to 2000 characters
  }

  /**
   * Determines image format from data URL
   */
  private getImageFormat(dataUrl: string): "PNG" | "JPEG" | "WEBP" {
    if (dataUrl.startsWith("data:image/jpeg")) return "JPEG";
    if (dataUrl.startsWith("data:image/webp")) return "PNG"; // jsPDF doesn't support WebP
    return "PNG";
  }

  /**
   * Validates PDF generation options
   */
  public validateOptions(options: PDFGenerationOptions): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (options.title && options.title.length > 100) {
      errors.push("Title must be less than 100 characters");
    }

    if (options.author && options.author.length > 100) {
      errors.push("Author must be less than 100 characters");
    }

    if (options.password && options.password.length < 4) {
      errors.push("Password must be at least 4 characters long");
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
}

// Export singleton instance
export const pdfService = PDFService.getInstance();
